---
title: "02_taxonomic_matching"
author: "Andreas Mehl"
date: "2025-01-14"
output: html_document
---
```{r}
# Added families to the function
WFO.match.fuzzyjoin_f <- function (spec.data = NULL, WFO.file = NULL, WFO.data = NULL, 
    no.dates = TRUE, spec.name = "spec.name", Genus = "Genus", 
    Family = "Family", 
    Species = "Species", Infraspecific.rank = "Infraspecific.rank", 
    Infraspecific = "Infraspecific", Authorship = "Authorship", 
    First.dist = FALSE, acceptedNameUsageID.match = TRUE, Fuzzy = 0.1, 
    Fuzzy.force = FALSE, Fuzzy.max = 250, Fuzzy.min = TRUE, Fuzzy.shortest = FALSE, 
    Fuzzy.within = FALSE, Fuzzy.two = TRUE, Fuzzy.one = TRUE, 
    squish = TRUE, spec.name.tolower = FALSE, spec.name.nonumber = TRUE, 
    spec.name.nobrackets = TRUE, exclude.infraspecific = FALSE, 
    infraspecific.excluded = c("cultivar.", "f.", "sect.", "subf.", 
        "subg.", "subsp.", "subvar.", "var", "var.", "[infraspec.]", 
        "fo.", "forma", "nothosubsp.", "nothovar.", "sect."), 
    spec.name.sub = TRUE, sub.pattern = c(" sp[.] A", " sp[.] B", 
        " sp[.] C", " sp[.]", " spp[.]", " pl[.]", " indet[.]", 
        " ind[.]", " gen[.]", " g[.]", " fam[.]", " nov[.]", 
        " prox[.]", " cf[.]", " aff[.]", " s[.]s[.]", " s[.]l[.]", 
        " p[.]p[.]", " p[.] p[.]", "[?]", " inc[.]", " stet[.]", 
        "Ca[.]", "nom[.] cons[.]", "nom[.] dub[.]", " nom[.] err[.]", 
        " nom[.] illeg[.]", " nom[.] inval[.]", " nom[.] nov[.]", 
        " nom[.] nud[.]", " nom[.] obl[.]", " nom[.] prot[.]", 
        " nom[.] rej[.]", " nom[.] supp[.]", " sensu auct[.]"), 
    verbose = TRUE, counter = 1000) 
{
    if (("data.table" %in% class(spec.data)) == TRUE) {
        spec.data <- data.frame(spec.data)
    }
    if (("data.frame" %in% class(spec.data)) == FALSE) {
        spec.data <- data.frame(spec.name = spec.data)
    }
    if (is.factor(spec.data) == TRUE) {
        spec.data <- data.frame(spec.name = spec.data)
    }
    if (!requireNamespace("data.table")) {
        stop("Please install the data.table package")
    }
    if (is.null(WFO.data) == TRUE) {
        message(paste("Reading WFO data"))
        WFO.data <- data.table::fread(WFO.file, encoding = "UTF-8")
    }
    else {
        WFO.data <- data.table::data.table(WFO.data)
    }
    if ("created" %in% names(WFO.data)) {
        data.table::set(WFO.data, j = "created", value = NULL)
    }
    if ("modified" %in% names(WFO.data)) {
        data.table::set(WFO.data, j = "modified", value = NULL)
    }
    WFO.names <- names(WFO.data)
    WFO.names <- c(WFO.names, "Hybrid")
    if (Authorship %in% names(spec.data)) {
        WFO.names <- c(WFO.names, "Auth.dist")
    }
    if (acceptedNameUsageID.match == TRUE) {
        if (Authorship %in% names(spec.data)) {
            WFO.names <- c(WFO.names, "New.accepted", "Old.status", 
                "Old.ID", "Old.name", "Old.author", "Old.author.dist")
        }
        else {
            WFO.names <- c(WFO.names, "New.accepted", "Old.status", 
                "Old.ID", "Old.name")
        }
    }
    for (i in 1:length(WFO.names)) {
        if (WFO.names[i] %in% names(spec.data)) {
            message(paste("Original data set variable '", WFO.names[i], 
                "' replaced by variable '", WFO.names[i], ".ORIG'", 
                sep = ""))
            names(spec.data)[names(spec.data) == WFO.names[i]] <- paste(WFO.names[i], 
                ".ORIG", sep = "")
        }
    }
    if (spec.name %in% names(spec.data)) {
        spec.data[, spec.name] <- as.character(spec.data[, spec.name])
        for (i in 1:nrow(spec.data)) {
            if (is.na(spec.data[i, spec.name]) == TRUE) {
                spec.data[i, spec.name] <- ""
            }
        }
        if (squish == TRUE) {
            spec.name.ORIG <- paste(spec.name, ".ORIG", sep = "")
            spec.data[, spec.name.ORIG] <- spec.data[, spec.name]
            spec.data[, spec.name] <- stringr::str_squish(spec.data[, 
                spec.name.ORIG])
            spec.data$Squished <- rep(as.logical(0), nrow(spec.data))
            for (i in 1:nrow(spec.data)) {
                if (nchar(spec.data[i, spec.name.ORIG]) > 0) {
                  if (spec.data[i, spec.name.ORIG] != spec.data[i, 
                    spec.name]) {
                    spec.data[i, "Squished"] <- as.logical(1)
                  }
                }
            }
        }
        if (spec.name.tolower == TRUE) {
            if (squish == FALSE) {
                spec.name.ORIG <- paste(spec.name, ".ORIG", sep = "")
                spec.data[, spec.name.ORIG] <- spec.data[, spec.name]
            }
            spec.data[, spec.name] <- tolower(spec.data[, spec.name.ORIG])
            for (i in 1:nrow(spec.data)) {
                substr(spec.data[i, spec.name], start = 1, stop = 1) <- toupper(substr(spec.data[i, 
                  spec.name], start = 1, stop = 1))
            }
        }
        if (spec.name.sub == TRUE) {
            if (squish == FALSE && spec.name.tolower == FALSE) {
                spec.name.ORIG <- paste(spec.name, ".ORIG", sep = "")
                spec.data[, spec.name.ORIG] <- spec.data[, spec.name]
            }
            for (i in 1:length(sub.pattern)) {
                spec.data[, spec.name] <- gsub(pattern = sub.pattern[i], 
                  replacement = "", x = spec.data[, spec.name])
            }
        }
        if (spec.name.nobrackets == TRUE) {
            if (squish == FALSE && spec.name.tolower == FALSE && 
                spec.name.sub == FALSE) {
                spec.name.ORIG <- paste(spec.name, ".ORIG", sep = "")
                spec.data[, spec.name.ORIG] <- spec.data[, spec.name]
            }
            spec.data$Brackets.detected <- rep(as.logical(0), 
                nrow(spec.data))
            for (i in 1:nrow(spec.data)) {
                species.string <- spec.data[i, spec.name]
                if (grepl(pattern = "[(]", x = species.string) == 
                  TRUE) {
                  spec.data[i, "Brackets.detected"] <- as.logical(1)
                  brack.place <- as.numeric(unlist(gregexpr(pattern = "[(]", 
                    text = species.string)))[1]
                  species.new.string <- substr(species.string, 
                    start = 1, stop = brack.place - 1)
                  spec.data[i, spec.name] <- stringr::str_squish(species.new.string)
                }
            }
        }
        if (spec.name.nonumber == TRUE) {
            if (squish == FALSE && spec.name.tolower == FALSE && 
                spec.name.sub == FALSE && spec.name.nobrackets == 
                FALSE) {
                spec.name.ORIG <- paste(spec.name, ".ORIG", sep = "")
                spec.data[, spec.name.ORIG] <- spec.data[, spec.name]
            }
            spec.data$Number.detected <- rep(as.logical(0), nrow(spec.data))
            for (i in 1:nrow(spec.data)) {
                species.string <- spec.data[i, spec.name]
                if (grepl("[[:digit:]]", species.string) == TRUE) {
                  spec.data[i, "Number.detected"] <- as.logical(1)
                  species.terms <- unlist(strsplit(species.string, 
                    split = " "))
                  species.new.string <- species.terms[1]
                  while (grepl("^[[:digit:]]", substr(species.new.string, 
                    start = nchar(species.new.string), stop = nchar(species.new.string))) == 
                    TRUE) {
                    species.new.string <- substr(species.new.string, 
                      start = 1, stop = nchar(species.new.string) - 
                        1)
                  }
                  spec.data[i, spec.name] <- species.new.string
                }
            }
        }
        if (any(grepl(" x ", spec.data[, spec.name])) == TRUE) {
            message(paste("pattern ' x ' was interpreted as hybrid notation and replaced by ' ", 
                intToUtf8(215), "'", sep = ""))
            if (squish == FALSE && spec.name.tolower == FALSE && 
                spec.name.sub == FALSE && spec.name.nonumber == 
                FALSE && spec.name.nobrackets == FALSE) {
                spec.name.ORIG <- paste(spec.name, ".ORIG", sep = "")
                spec.data[, spec.name.ORIG] <- spec.data[, spec.name]
            }
            for (i in 1:nrow(spec.data)) {
                species.string <- spec.data[i, spec.name]
                if (grepl(" x ", species.string) == TRUE) {
                  species.new.string <- gsub(pattern = " x ", 
                    replacement = paste(" ", intToUtf8(215), 
                      sep = ""), x = species.string)
                  spec.data[i, spec.name] <- species.new.string
                }
            }
        }
    }
    if (Genus %in% names(spec.data)) {
        spec.data[, Genus] <- as.character(spec.data[, Genus])
    }
    if (Species %in% names(spec.data)) {
        spec.data[, Species] <- as.character(spec.data[, Species])
    }
    if (Infraspecific.rank %in% names(spec.data)) {
        spec.data[, Infraspecific.rank] <- as.character(spec.data[, 
            Infraspecific.rank])
    }
    if (Infraspecific %in% names(spec.data)) {
        spec.data[, Infraspecific] <- as.character(spec.data[, 
            Infraspecific])
    }
    spec.data$Matched <- spec.data$Unique <- rep(as.logical(1), 
        nrow(spec.data))
    spec.data$Fuzzy <- rep(as.logical(0), nrow(spec.data))
    spec.data$Fuzzy.toomany <- rep(as.logical(0), nrow(spec.data))
    spec.data$Fuzzy.two <- rep(as.logical(0), nrow(spec.data))
    spec.data$Fuzzy.one <- rep(as.logical(0), nrow(spec.data))
    spec.data$Fuzzy.dist <- rep(NA, nrow(spec.data))
    if (Authorship %in% names(spec.data)) {
        spec.data$Auth.dist <- rep(Inf, nrow(spec.data))
    }
    if (First.dist == TRUE) {
        spec.data$First.dist <- rep(Inf, nrow(spec.data))
    }
    spec.data$OriSeq <- c(1:nrow(spec.data))
    spec.data$Subseq <- rep(1, nrow(spec.data))
    init.column <- ncol(spec.data)
    if (Infraspecific.rank %in% names(spec.data)) {
        for (i in 1:nrow(spec.data)) {
            if (is.na(spec.data[i, Infraspecific.rank]) == TRUE) {
                spec.data[i, Infraspecific.rank] <- ""
            }
        }
    }
    if (Infraspecific %in% names(spec.data)) {
        for (i in 1:nrow(spec.data)) {
            if (is.na(spec.data[i, Infraspecific]) == TRUE) {
                spec.data[i, Infraspecific.rank] <- ""
            }
        }
    }
    WFO.empty <- WFO.data[1, ]
    for (i in 1:ncol(WFO.empty)) {
        WFO.empty[, i] <- ""
    }
    if (spec.name %in% names(spec.data)) {
        WFO.dat <- WFO.data[, c("taxonID", "scientificName")]
        WFO.empt <- WFO.empty[, c("taxonID", "scientificName")]
        spec.data$spec.link <- spec.data[, spec.name]
        if (Fuzzy.force == FALSE) {
            WFO.full <- dplyr::left_join(spec.data, WFO.dat, 
                by = c(spec.link = "scientificName"))
            remain.ind <- WFO.full[is.na(WFO.full$taxonID) == 
                TRUE, "OriSeq"]
            WFO.full <- WFO.full[is.na(WFO.full$taxonID) == FALSE, 
                ]
            if (nrow(WFO.full) > 0) {
                full.matches <- TRUE
                seq.unique <- unique(WFO.full$OriSeq)
                for (i in 1:length(seq.unique)) {
                  un.r <- nrow(WFO.full[WFO.full$OriSeq == seq.unique[i], 
                    ])
                  if (un.r > 1) {
                    WFO.full[WFO.full$OriSeq == seq.unique[i], 
                      "Subseq"] <- c(1:un.r)
                  }
                }
                spec.data <- spec.data[spec.data$OriSeq %in% 
                  remain.ind, ]
                n.remain <- nrow(spec.data)
            }
            else {
                full.matches <- FALSE
                n.remain <- nrow(spec.data)
            }
        }
        if (n.remain > 0) {
            message(paste("Checking for fuzzy matches for ", 
                n.remain, " records", sep = ""))
            if (verbose == TRUE) {
                for (i in 1:nrow(spec.data)) {
                  if (round(i/counter, 0) == i/counter) {
                    message(paste("Reached record # ", i, sep = ""))
                  }
                  fuzzy.matches <- FALSE
                  spec.data.i1 <- spec.data.i <- spec.data[i, 
                    spec.name]
                  if (spec.data.i %in% c("Compositae", "Leguminosae", 
                    "Umbelliferae", "Palmae", "Cruciferae", "Guttiferae", 
                    "Labiatae", "Gramineae")) {
                    if (spec.data.i == "Compositae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Asteraceae", ]
                    }
                    if (spec.data.i == "Leguminosae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Fabaceae", ]
                    }
                    if (spec.data.i == "Umbelliferae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Apiaceae", ]
                    }
                    if (spec.data.i == "Palmae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Arecaceae", ]
                    }
                    if (spec.data.i == "Cruciferae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Brassicaceae", ]
                    }
                    if (spec.data.i == "Guttiferae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Clusiaceae", ]
                    }
                    if (spec.data.i == "Labiatae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Lamiaceae", ]
                    }
                    if (spec.data.i == "Gramineae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Poaceae", ]
                    }
                  }
                  else if (nchar(spec.data.i) > 0 && Fuzzy > 
                    0) {
                    if (Fuzzy > 0 || Fuzzy.force == TRUE) {
                      specFuzzy <- agrep(spec.data.i, x = WFO.dat$scientificName, 
                        value = T, max.distance = Fuzzy)
                      if (length(specFuzzy) == 0 && Fuzzy.two == 
                        TRUE) {
                        species.string <- spec.data.i
                        species.terms <- unlist(strsplit(species.string, 
                          split = " "))
                        if (length(species.terms) > 2) {
                          species.string2 <- paste(species.terms[1], 
                            " ", species.terms[2], sep = "")
                          specFuzzy <- agrep(species.string2, 
                            x = WFO.dat$scientificName, value = T, 
                            max.distance = Fuzzy)
                          spec.data[i, "Fuzzy.two"] <- as.logical(1)
                          if (length(specFuzzy) > 0) {
                            message(paste("Fuzzy matches for ", 
                              spec.data.i, " were only found for first 2 terms (", 
                              species.string2, ")", sep = ""))
                            spec.data.i <- species.string2
                            specFuzzy.2 <- NULL
                            for (j in 1:length(specFuzzy)) {
                              species.string3 <- unlist(strsplit(specFuzzy[j], 
                                split = " "))
                              if (length(species.string3) < 3) {
                                specFuzzy.2 <- c(specFuzzy.2, 
                                  specFuzzy[j])
                              }
                            }
                            if (length(specFuzzy.2) > 0) {
                              message(paste("With Fuzzy.two, reduced matches to those of 2 words only"))
                              specFuzzy <- specFuzzy.2
                            }
                          }
                        }
                      }
                      if (length(specFuzzy) == 0 && Fuzzy.one == 
                        TRUE) {
                        species.string <- spec.data.i
                        species.string2 <- unlist(strsplit(species.string, 
                          split = " "))[1]
                        if (nchar(species.string2) > 2) {
                          spec.data[i, "Fuzzy.one"] <- as.logical(1)
                          WFO.match <- WFO.dat[WFO.dat$scientificName == 
                            species.string2, ]
                          if ((nrow(WFO.match) == 0 && Fuzzy > 
                            0) || Fuzzy.force == TRUE) {
                            specFuzzy <- agrep(species.string2, 
                              x = WFO.dat$scientificName, value = T, 
                              max.distance = Fuzzy)
                            if (length(specFuzzy) > 0) {
                              message(paste("Fuzzy matches for ", 
                                spec.data.i, " were only found for first term (", 
                                species.string2, ")", sep = ""))
                              spec.data.i <- species.string2
                              specFuzzy.2 <- NULL
                              for (j in 1:length(specFuzzy)) {
                                species.string3 <- unlist(strsplit(specFuzzy[j], 
                                  split = " "))
                                if (length(species.string3) < 
                                  2) {
                                  specFuzzy.2 <- c(specFuzzy.2, 
                                    specFuzzy[j])
                                }
                              }
                              if (length(specFuzzy.2) > 0) {
                                message(paste("With Fuzzy.one, reduced matches to those of 1 word only"))
                                specFuzzy <- specFuzzy.2
                              }
                            }
                          }
                          else {
                            specFuzzy <- NULL
                            spec.data[i, "Fuzzy"] <- as.logical(1)
                            fuzzy.matches <- TRUE
                          }
                        }
                      }
                      if (length(specFuzzy) > Fuzzy.max) {
                        spec.data[i, "Fuzzy.toomany"] <- length(specFuzzy)
                        message(paste("Too many (", length(specFuzzy), 
                          ") fuzzy matches for ", spec.data.i, 
                          ", including ", specFuzzy[1], sep = ""))
                        specFuzzy <- NULL
                        spec.data[i, "Matched"] <- as.logical(0)
                        WFO.match <- WFO.empt
                      }
                      if (length(specFuzzy) > 0) {
                        spec.data[i, "Fuzzy"] <- as.logical(1)
                        fuzzy.matches <- TRUE
                        specFuzzy <- unique(specFuzzy)
                        message(paste("Fuzzy matches for ", spec.data.i1, 
                          "were: ", paste(specFuzzy, collapse = ", ")))
                        if (Fuzzy.within == TRUE) {
                          Fuzzy.shortest <- Fuzzy.min <- FALSE
                          within.matches <- grepl(spec.data.i, 
                            x = specFuzzy)
                          specFuzzy <- specFuzzy[within.matches]
                          if (length(specFuzzy) > 0) {
                            message(paste("Matches within for ", 
                              spec.data.i1, "were: ", paste(specFuzzy, 
                                collapse = ", ")))
                          }
                          else {
                            message(paste("No matches within for ", 
                              spec.data.i1))
                          }
                        }
                        if (Fuzzy.min == TRUE && length(specFuzzy) > 
                          1) {
                          Fuzzy.shortest <- FALSE
                          Fuzzy.dist <- as.numeric(utils::adist(specFuzzy, 
                            y = spec.data.i))
                          target.l <- min(Fuzzy.dist)
                          specFuzzy <- specFuzzy[Fuzzy.dist == 
                            target.l]
                          message(paste("Best fuzzy matches for ", 
                            spec.data.i1, "were: ", paste(specFuzzy, 
                              collapse = ", ")))
                        }
                        if (Fuzzy.shortest == TRUE && length(specFuzzy) > 
                          1) {
                          target.l <- nchar(spec.data.i)
                          found.l <- nchar(specFuzzy)
                          found.diff <- abs(found.l - target.l)
                          specFuzzy <- specFuzzy[found.diff == 
                            min(found.diff)]
                          message(paste("Shortest fuzzy matches for ", 
                            spec.data.i1, "were: ", paste(specFuzzy, 
                              collapse = ", ")))
                        }
                        for (j in 1:length(specFuzzy)) {
                          WFO.match1 <- WFO.dat[WFO.dat$scientificName == 
                            specFuzzy[j], ]
                          if (j == 1) {
                            WFO.match <- WFO.match1
                          }
                          else {
                            WFO.match <- rbind(WFO.match, WFO.match1)
                          }
                        }
                      }
                    }
                    if (nrow(WFO.match) > 1) {
                      spec.data[i, "Unique"] <- as.logical(0)
                      WFO.match2 <- cbind(spec.data[rep(i, nrow(WFO.match)), 
                        ], WFO.match)
                      WFO.match2$Subseq <- c(1:nrow(WFO.match))
                    }
                    else if (nrow(WFO.match) == 1) {
                      WFO.match2 <- cbind(spec.data[i, ], WFO.match)
                    }
                    else {
                      spec.data[i, "Matched"] <- as.logical(0)
                      WFO.match2 <- cbind(spec.data[i, ], WFO.empt)
                    }
                    if (fuzzy.matches == TRUE) {
                      for (j in 1:nrow(WFO.match2)) {
                        WFO.match2[j, "Fuzzy.dist"] <- as.numeric(utils::adist(WFO.match2[j, 
                          "scientificName"], y = spec.data.i1))
                        if (First.dist == TRUE) {
                          genus.input <- spec.data.i
                          genus.input2 <- unlist(strsplit(genus.input, 
                            split = " "))[1]
                          genus.match <- WFO.match2[j, "scientificName"]
                          genus.match2 <- unlist(strsplit(genus.match, 
                            split = " "))[1]
                          Fuzzy.dist1 <- as.numeric(utils::adist(genus.input2, 
                            y = genus.match2))
                          if (is.na(Fuzzy.dist1) == TRUE) {
                            Fuzzy.dist1 <- Inf
                          }
                          WFO.match2[j, "First.dist"] <- Fuzzy.dist1
                        }
                      }
                    }
                  }
                  else {
                    spec.data[i, "Matched"] <- as.logical(0)
                    WFO.match2 <- cbind(spec.data[i, ], WFO.empt)
                  }
                  if (i == 1) {
                    WFO.out <- WFO.match2
                  }
                  else {
                    WFO.out <- rbind(WFO.out, WFO.match2)
                  }
                }
            }
            else {
                for (i in 1:nrow(spec.data)) {
                  fuzzy.matches <- FALSE
                  spec.data.i1 <- spec.data.i <- spec.data[i, 
                    spec.name]
                  if (spec.data.i %in% c("Compositae", "Leguminosae", 
                    "Umbelliferae", "Palmae", "Cruciferae", "Guttiferae", 
                    "Labiatae", "Gramineae")) {
                    if (spec.data.i == "Compositae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Asteraceae", ]
                    }
                    if (spec.data.i == "Leguminosae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Fabaceae", ]
                    }
                    if (spec.data.i == "Umbelliferae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Apiaceae", ]
                    }
                    if (spec.data.i == "Palmae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Arecaceae", ]
                    }
                    if (spec.data.i == "Cruciferae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Brassicaceae", ]
                    }
                    if (spec.data.i == "Guttiferae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Clusiaceae", ]
                    }
                    if (spec.data.i == "Labiatae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Lamiaceae", ]
                    }
                    if (spec.data.i == "Gramineae") {
                      WFO.match <- WFO.dat[WFO.dat$scientificName == 
                        "Poaceae", ]
                    }
                  }
                  else if (nchar(spec.data.i) > 0 && Fuzzy > 
                    0) {
                    if (Fuzzy > 0 || Fuzzy.force == TRUE) {
                      specFuzzy <- agrep(spec.data.i, x = WFO.dat$scientificName, 
                        value = T, max.distance = Fuzzy)
                      if (length(specFuzzy) == 0 && Fuzzy.two == 
                        TRUE) {
                        species.string <- spec.data.i
                        species.terms <- unlist(strsplit(species.string, 
                          split = " "))
                        if (length(species.terms) > 2) {
                          species.string2 <- paste(species.terms[1], 
                            " ", species.terms[2], sep = "")
                          specFuzzy <- agrep(species.string2, 
                            x = WFO.dat$scientificName, value = T, 
                            max.distance = Fuzzy)
                          spec.data[i, "Fuzzy.two"] <- as.logical(1)
                          if (length(specFuzzy) > 0) {
                            spec.data.i <- species.string2
                            specFuzzy.2 <- NULL
                            for (j in 1:length(specFuzzy)) {
                              species.string3 <- unlist(strsplit(specFuzzy[j], 
                                split = " "))
                              if (length(species.string3) < 3) {
                                specFuzzy.2 <- c(specFuzzy.2, 
                                  specFuzzy[j])
                              }
                            }
                            if (length(specFuzzy.2) > 0) {
                              specFuzzy <- specFuzzy.2
                            }
                          }
                        }
                      }
                      if (length(specFuzzy) == 0 && Fuzzy.one == 
                        TRUE) {
                        species.string <- spec.data.i
                        species.string2 <- unlist(strsplit(species.string, 
                          split = " "))[1]
                        if (nchar(species.string2) > 2) {
                          spec.data[i, "Fuzzy.one"] <- as.logical(1)
                          WFO.match <- WFO.dat[WFO.dat$scientificName == 
                            species.string2, ]
                          if ((nrow(WFO.match) == 0 && Fuzzy > 
                            0) || Fuzzy.force == TRUE) {
                            specFuzzy <- agrep(species.string2, 
                              x = WFO.dat$scientificName, value = T, 
                              max.distance = Fuzzy)
                            if (length(specFuzzy) > 0) {
                              spec.data.i <- species.string2
                              specFuzzy.2 <- NULL
                              for (j in 1:length(specFuzzy)) {
                                species.string3 <- unlist(strsplit(specFuzzy[j], 
                                  split = " "))
                                if (length(species.string3) < 
                                  2) {
                                  specFuzzy.2 <- c(specFuzzy.2, 
                                    specFuzzy[j])
                                }
                              }
                              if (length(specFuzzy.2) > 0) {
                                specFuzzy <- specFuzzy.2
                              }
                            }
                          }
                          else {
                            specFuzzy <- NULL
                            spec.data[i, "Fuzzy"] <- as.logical(1)
                            fuzzy.matches <- TRUE
                          }
                        }
                      }
                      if (length(specFuzzy) > Fuzzy.max) {
                        spec.data[i, "Fuzzy.toomany"] <- length(specFuzzy)
                        specFuzzy <- NULL
                        spec.data[i, "Matched"] <- as.logical(0)
                        WFO.match <- WFO.empt
                      }
                      if (length(specFuzzy) > 0) {
                        spec.data[i, "Fuzzy"] <- as.logical(1)
                        fuzzy.matches <- TRUE
                        specFuzzy <- unique(specFuzzy)
                        if (Fuzzy.within == TRUE) {
                          Fuzzy.shortest <- Fuzzy.min <- FALSE
                          within.matches <- grepl(spec.data.i, 
                            x = specFuzzy)
                          specFuzzy <- specFuzzy[within.matches]
                        }
                        if (Fuzzy.min == TRUE && length(specFuzzy) > 
                          1) {
                          Fuzzy.shortest <- FALSE
                          Fuzzy.dist <- as.numeric(utils::adist(specFuzzy, 
                            y = spec.data.i))
                          target.l <- min(Fuzzy.dist)
                          specFuzzy <- specFuzzy[Fuzzy.dist == 
                            target.l]
                        }
                        if (Fuzzy.shortest == TRUE && length(specFuzzy) > 
                          1) {
                          target.l <- nchar(spec.data.i)
                          found.l <- nchar(specFuzzy)
                          found.diff <- abs(found.l - target.l)
                          specFuzzy <- specFuzzy[found.diff == 
                            min(found.diff)]
                        }
                        for (j in 1:length(specFuzzy)) {
                          WFO.match1 <- WFO.dat[WFO.dat$scientificName == 
                            specFuzzy[j], ]
                          if (j == 1) {
                            WFO.match <- WFO.match1
                          }
                          else {
                            WFO.match <- rbind(WFO.match, WFO.match1)
                          }
                        }
                      }
                    }
                    if (nrow(WFO.match) > 1) {
                      spec.data[i, "Unique"] <- as.logical(0)
                      WFO.match2 <- cbind(spec.data[rep(i, nrow(WFO.match)), 
                        ], WFO.match)
                      WFO.match2$Subseq <- c(1:nrow(WFO.match))
                    }
                    else if (nrow(WFO.match) == 1) {
                      WFO.match2 <- cbind(spec.data[i, ], WFO.match)
                    }
                    else {
                      spec.data[i, "Matched"] <- as.logical(0)
                      WFO.match2 <- cbind(spec.data[i, ], WFO.empt)
                    }
                    if (fuzzy.matches == TRUE) {
                      for (j in 1:nrow(WFO.match2)) {
                        WFO.match2[j, "Fuzzy.dist"] <- as.numeric(utils::adist(WFO.match2[j, 
                          "scientificName"], y = spec.data.i1))
                        if (First.dist == TRUE) {
                          genus.input2 <- unlist(strsplit(spec.data.i, 
                            split = " "))[1]
                          genus.match <- WFO.match2[j, "scientificName"]
                          genus.match2 <- unlist(strsplit(genus.match, 
                            split = " "))[1]
                          Fuzzy.dist1 <- as.numeric(utils::adist(genus.input2, 
                            y = genus.match2))
                          if (is.na(Fuzzy.dist1) == TRUE) {
                            Fuzzy.dist1 <- Inf
                          }
                          WFO.match2[j, "First.dist"] <- Fuzzy.dist1
                        }
                      }
                    }
                  }
                  else {
                    spec.data[i, "Matched"] <- as.logical(0)
                    WFO.match2 <- cbind(spec.data[i, ], WFO.empt)
                  }
                  if (i == 1) {
                    WFO.out <- WFO.match2
                  }
                  else {
                    WFO.out <- rbind(WFO.out, WFO.match2)
                  }
                }
            }
            WFO.out <- WFO.out[, !names(WFO.out) %in% c("scientificName")]
            if (full.matches == TRUE) {
                WFO.out <- rbind(WFO.full, WFO.out)
                WFO.out <- WFO.out[order(WFO.out$OriSeq, WFO.out$Subseq), 
                  ]
            }
        }
        else {
            WFO.out <- WFO.full
        }
        WFO.out <- WFO.out[, !names(WFO.out) %in% c("spec.link")]
        WFO.out <- dplyr::left_join(WFO.out, WFO.data, by = "taxonID")
    }
    else {
        for (i in 1:nrow(spec.data)) {
            if (Infraspecific.rank %in% names(spec.data)) {
                WFO.match <- WFO.data[WFO.data$genus == spec.data[i, 
                  Genus] & WFO.data$specificEpithet == spec.data[i, 
                  Species] & WFO.data$verbatimTaxonRank == spec.data[i, 
                  Infraspecific.rank] & WFO.data$infraspecificEpithet == 
                  spec.data[i, Infraspecific], ]
            }
            else if (Infraspecific %in% names(spec.data)) {
                WFO.match <- WFO.data[WFO.data$genus == spec.data[i, 
                  Genus] & WFO.data$specificEpithet == spec.data[i, 
                  Species] & WFO.data$infraspecificEpithet == 
                  spec.data[i, Infraspecific], ]
            }
            else if (Species %in% names(spec.data)) {
                WFO.match <- WFO.data[WFO.data$genus == spec.data[i, 
                  Genus] & WFO.data$specificEpithet == spec.data[i, 
                  Species], ]
            }
			else if (Species %in% names(spec.data)) {
                WFO.match <- WFO.data[WFO.data$family == spec.data[i, 
                  Family] & WFO.data$specificEpithet == spec.data[i, 
                  Species], ]
            }
            else {
                WFO.match <- WFO.data[WFO.data$genus == spec.data[i, 
                  Genus], ]
            }
            if (nrow(WFO.match) > 1) {
                spec.data[i, "Unique"] <- as.logical(0)
                WFO.match2 <- cbind(spec.data[rep(i, nrow(WFO.match)), 
                  ], WFO.match)
                WFO.match2$Subseq <- c(1:nrow(WFO.match))
            }
            else if (nrow(WFO.match) == 1) {
                WFO.match2 <- cbind(spec.data[i, ], WFO.match)
            }
            else {
                spec.data[i, "Matched"] <- as.logical(0)
                WFO.match2 <- cbind(spec.data[i, ], WFO.empty)
            }
            if (i == 1) {
                WFO.out <- WFO.match2
            }
            else {
                WFO.out <- rbind(WFO.out, WFO.match2)
            }
        }
    }
    WFO.out$Hybrid <- rep("", nrow(WFO.out))
    for (i in 1:nrow(WFO.out)) {
        if (grepl(intToUtf8(215), WFO.out[i, "scientificName"])) {
            WFO.out[i, "Hybrid"] <- intToUtf8(215)
        }
    }
    if (acceptedNameUsageID.match == TRUE) {
        message(paste0("\n", "Checking new accepted IDs"))
        right.columns <- c((init.column + 1):(ncol(WFO.out) - 
            1))
        WFO.out$New.accepted <- rep(as.logical(0), nrow(WFO.out))
        WFO.out$Old.status <- rep("", nrow(WFO.out))
        WFO.out$Old.ID <- rep("", nrow(WFO.out))
        WFO.out$Old.name <- rep("", nrow(WFO.out))
        if (Authorship %in% names(spec.data)) {
            WFO.out$Old.author <- rep("", nrow(WFO.out))
            WFO.out$Old.author.dist <- rep("", nrow(WFO.out))
        }
        for (i in 1:nrow(WFO.out)) {
            if (is.na(WFO.out[i, "acceptedNameUsageID"]) == TRUE) {
                WFO.out[i, "acceptedNameUsageID"] <- ""
            }
            if (WFO.out[i, "acceptedNameUsageID"] != "") {
                WFO.match <- WFO.data[WFO.data$taxonID == WFO.out[i, 
                  "acceptedNameUsageID"], ]
                if (nrow(WFO.match) == 0) {
                  warning(paste("WARNING: no data for ", WFO.out[i, 
                    "acceptedNameUsageID"], " from ", WFO.out[i, 
                    "scientificName"]))
                }
                else if (nrow(WFO.match) > 1) {
                  warning(paste("WARNING: more than 1 row of matches for ", 
                    WFO.out[i, "acceptedNameUsageID"], " from ", 
                    WFO.out[i, "scientificName"]))
                }
                else {
                  WFO.out[i, "New.accepted"] <- as.logical(1)
                  WFO.out[i, "Old.status"] <- WFO.out[i, "taxonomicStatus"]
                  WFO.out[i, "Old.ID"] <- WFO.out[i, "taxonID"]
                  WFO.out[i, "Old.name"] <- WFO.out[i, "scientificName"]
                  if (Authorship %in% names(spec.data)) {
                    WFO.out[i, "Old.author"] <- WFO.out[i, "scientificNameAuthorship"]
                    Fuzzy.dist <- as.numeric(utils::adist(WFO.out[i, 
                      Authorship], y = WFO.out[i, "scientificNameAuthorship"]))
                    if (is.na(Fuzzy.dist) == TRUE) {
                      Fuzzy.dist <- Inf
                    }
                    WFO.out[i, "Old.author.dist"] <- Fuzzy.dist
                  }
                  WFO.out[i, right.columns] <- WFO.match
                  if (grepl(intToUtf8(215), WFO.out[i, "scientificName"])) {
                    WFO.out[i, "Hybrid"] <- intToUtf8(215)
                  }
                  else {
                    WFO.out[i, "Hybrid"] <- ""
                  }
                }
            }
        }
    }
    if (exclude.infraspecific == TRUE) {
        keep.rows <- rep(as.logical(1), nrow(WFO.out))
        for (i in 1:nrow(WFO.out)) {
            if (WFO.out[i, "verbatimTaxonRank"] %in% infraspecific.excluded) {
                keep.rows[i] <- as.logical(0)
            }
        }
        WFO.out <- WFO.out[keep.rows, ]
    }
    if (Authorship %in% names(spec.data)) {
        for (i in 1:nrow(WFO.out)) {
            Fuzzy.dist <- as.numeric(utils::adist(WFO.out[i, 
                Authorship], y = WFO.out[i, "scientificNameAuthorship"]))
            if (is.na(Fuzzy.dist) == TRUE) {
                Fuzzy.dist <- Inf
            }
            WFO.out[i, "Auth.dist"] <- Fuzzy.dist
        }
    }
    return(WFO.out)
}


```

<p> </p>



```{r}
getOption('encoding')
options(locale = locale(encoding = "UTF-8"))

# Load the file used in the analyses, e.g. taxonomic scrubbing to adapt the raw data to this structure
load("output/Joined_finalPOWdist.v2.Rdata")

# What objects are there?
ls()# some

# What is the data structure:
str(some)
is(some)# the format


# Take the raw data from Maria Judith and adapt it to this structure:
#load("data/database_clean.rda") See which version Andreas used

load("data/database_final.rda")
# This is the clean data:
str(occs_final)
length(unique(occs_final$species))# here the species
length(unique(occs_final$prevScientificName))

##
# We upload our backbone!
backbone_f_fromSH <-read.xlsx("F:/Academic/b_Projects/EPIG_R/backbone/backbone_firstdraft_sentSH_october.xlsx",1)
backbone_f_fromSH

# We need to separate the author names:
# How many words in the author columns are there?
max(sapply(strsplit(backbone_f_fromSH$AUTHOR, " "), length))
##
# Cbinding the separation of spp and authors to the main file:
backbone_f_fromSH <- cbind(backbone_f_fromSH,
utils::strcapture("^(\\S+(?:\\s+\\S+)?)?(?:\\s+(.+))?", backbone_f_fromSH$AUTHOR, 
                  list(spp = character(),
                       Author = character())))
# We change the "TRUE"/FALSE for SYNONYM
head(backbone_f_fromSH)
ifelse(backbone_f_fromSH$SYNONYM == "TRUE",
       "SYNONYM", " ")

##
# We create the new backbone file!
EpIG.backbone <- new.backbone(backbone_f_fromSH,
                         taxonID = "SPECIES_NR",
                         scientificName = "ABBREVIAT",
                        scientificNameAuthorship = "Author",
                        acceptedNameUsageID = "ID_VALID", 
                        taxonomicStatus = "SYNONYM")
head(EpIG.backbone)
EpIG.backbone <- EpIG.backbone[,-(6:16)]

##
# We create the list from the occurrences, so that it goes quickly:
# epis_occ: epiphyte occurrences list (prevScientificName, which is the original name from the databases)
epis_occ <- unique(occs_final$prevScientificName)# with >11 000 spp
#EpIsOcc
epis_occ <- data.frame(epis_occ) # 
colnames(epis_occ) <- "spec.name"
head(epis_occ)

##
# We match the occurrences list to the EpIG Backbone:
# Resulting in the object "EpIG_occ.match"
#system.time(EpIG_occ.match <- WFO.one(WFO.match(epis_occ,
#                                      WFO.data = EpIG.backbone,
#                                      spec.name = "spec.name")))
# Started 21/11/2024 15:55 (with a break, sleeping pc, between 16:30 and 18:00), finished in 18:40
#    user  system elapsed 
# 1126.39   31.36 9352.56 

##
# We save both results, the Backbone converted in the WFO format (EpIG.backbone) and the matching of epiphyte ocurrences list (EpIG_occ.match)
# save(EpIG.backbone,
#      EpIG_occ.match,
#      file = "data/EpIGbackbone_and_matched_ocurrences.Rdata")
load("data/EpIGbackbone_and_matched_ocurrences.Rdata")

# Output
head(EpIG_occ.match)
table(EpIG_occ.match$Matched)
```

I also need to get the family and genus for each species, for both, the names which came out of the matched or "new" (from the backbone) and for those we used to enter or those SPECIES.ORIG. I do so here, but at the end I need to reconstruct a new dataframe contaning all information from the data from Maria Judith, plus the following fields:

prev.Family = epis_occ_families$families
prev.Genus = epis_occ_families$genus
Family = epis_occ_families_new$families
Genus = epis_occ_families_new$genus
prevFullName = EpIG_occ.match$spec.name.ORIG
prevscientificName = EpIG_occ.match$scientificName
```{r}

# Checking the output:
colnames(EpIG_occ.match)
table(is.na(EpIG_occ.match$scientificName))
table(EpIG_occ.match$taxonomicStatus)
length(EpIG_occ.match[EpIG_occ.match$Matched == "FALSE",])

# Number of unique "acceptedNameUsageID" and unique "Species.ORIG"
c(length(unique(EpIG_occ.match$acceptedNameUsageID)),
  length(unique(EpIG_occ.match$spec.name.ORIG)))
# There is a minus of 255 "species" (when using "species" which are a unique 11 446: 11 191)
# Here, using "prevScientificName", with a total of 15 937 unique entities, with a minus of 4 652 "species", resulting on a total of 11 285 (similar # to above). 


# Get the families and genera!
# Use this function as it is much faster to families:

# wfo_backbone <- "F:/Academic/b_Projects/CONTINENT/Manuscripts/LatitudinalDivesityEpis/Analyses/R_Script/DONE/classification.csv"

# epis_occ_1 <- data.frame(spec.name = epis_occ[1:5300,])
# epis_occ_1 <- as.matrix(epis_occ_1)
# epis_occ_2 <- data.frame(spec.name = epis_occ[5301:10600,])
# epis_occ_2 <- as.matrix(epis_occ_2)
# epis_occ_3 <- data.frame(spec.name = epis_occ[10601:12000,])
# epis_occ_3 <- as.matrix(epis_occ_3)
# epis_occ_4<- data.frame(spec.name = epis_occ[12001:13500,])
# epis_occ_4 <- as.matrix(epis_occ_4)
# epis_occ_5 <- data.frame(spec.name = epis_occ[13501:15937])
# epis_occ_5 <- as.matrix(epis_occ_5)
# 
# epis_occ_families_1 <- WFO.match.fuzzyjoin(spec.data = epis_occ_1, 
#                     WFO.file = "F:/Academic/b_Projects/CONTINENT/Manuscripts/LatitudinalDivesityEpis/Analyses/R_Script/DONE/classification.csv", 
#                     spec.name = "spec.name", 
#                     no.dates = FALSE, 
#                     Authorship = "Authorship",
#                     Fuzzy.min = TRUE,
#                     acceptedNameUsageID.match = TRUE,
#                     squish = TRUE)
# # This took from 15:35 to 14:43
# epis_occ_families_2 <- WFO.match.fuzzyjoin(spec.data = epis_occ_2, 
#                     WFO.file = "F:/Academic/b_Projects/CONTINENT/Manuscripts/LatitudinalDivesityEpis/Analyses/R_Script/DONE/classification.csv", 
#                     spec.name = "spec.name", 
#                     no.dates = FALSE, 
#                     Authorship = "Authorship",
#                     Fuzzy.min = TRUE,
#                     acceptedNameUsageID.match = TRUE,
#                     squish = TRUE)
# # This takes from 15:44 to 15:50 to 16:16
# 
# epis_occ_families_3 <- WFO.match.fuzzyjoin(spec.data = epis_occ_3, 
#                     WFO.file = "F:/Academic/b_Projects/CONTINENT/Manuscripts/LatitudinalDivesityEpis/Analyses/R_Script/DONE/classification.csv", 
#                     spec.name = "spec.name", 
#                     no.dates = FALSE, 
#                     Authorship = "Authorship",
#                     Fuzzy.min = TRUE,
#                     acceptedNameUsageID.match = TRUE,
#                     squish = TRUE)
# # This takes from 18:38 to 18:
# 
# epis_occ_families_4 <- WFO.match.fuzzyjoin(spec.data = epis_occ_4, 
#                     WFO.file = "F:/Academic/b_Projects/CONTINENT/Manuscripts/LatitudinalDivesityEpis/Analyses/R_Script/DONE/classification.csv", 
#                     spec.name = "spec.name", 
#                     no.dates = FALSE, 
#                     Authorship = "Authorship",
#                     Fuzzy.min = TRUE,
#                     acceptedNameUsageID.match = TRUE,
#                     squish = TRUE)
# # This takes from 13:18 to 13:26
# 
# epis_occ_5 <- as.matrix(epis_occ_5)
# epis_occ_families_5 <- WFO.match.fuzzyjoin(spec.data = epis_occ_5, 
#                     WFO.file = "F:/Academic/b_Projects/CONTINENT/Manuscripts/LatitudinalDivesityEpis/Analyses/R_Script/DONE/classification.csv", 
#                     spec.name = "spec.name", 
#                     no.dates = FALSE, 
#                     Authorship = "Authorship",
#                     Fuzzy.min = TRUE,
#                     acceptedNameUsageID.match = TRUE,
#                     squish = TRUE)
# This takes from 13:26 to 13:36
# I do not know what happened, that it needed to be made into smallers vectors, I got the problem about allocation of vector Xgb, which was not needed for the one below.
#
# epis_occ_families <- rbind(epis_occ_families_1,
#                            epis_occ_families_2,
#                            epis_occ_families_3,
#                            epis_occ_families_4,
#                            epis_occ_families_5)
#
# save(epis_occ_families,
#      file="data/occ_families_all.Rdata")
load("data/occ_families_all.Rdata")


# Revising the output:
# It is expected that only five families should be present, therefore we inspect closer the following families:
epis_occ_families[epis_occ_families$family %in% 
                    c("Amaranthaceae",
                      "Asparagaceae",
                      "Aspleniaceae",
                      "Athyriaceae",
                      "Cucurbitaceae",
                      "Dryopteridaceae",
                      "Fabaceae",
                      "Lythraceae",
                      "Melastomataceae",
                      "Meteoriaceae",
                      "Primulaceae",
                      "Pteridaceae",
                      "Thelypteridaceae"),]
# Species origin vs new
epis_occ_families[epis_occ_families$family %in% 
                    c("Amaranthaceae",
                      "Asparagaceae",
                      "Aspleniaceae",
                      "Athyriaceae",
                      "Cucurbitaceae",
                      "Dryopteridaceae",
                      "Fabaceae",
                      "Lythraceae",
                      "Melastomataceae",
                      "Meteoriaceae",
                      "Primulaceae",
                      "Pteridaceae",
                      "Thelypteridaceae"),c(2,15)]
# It is clear these are mistakes from a combination between the function and the content within WFO:
#
#
# Tillandsia juncea (Ruiz & Pav.) Poir. is a Bromeliaceae, but there is another species with similar binomial name but with a different author: Tillandsia juncea Willd. ex Steud. which is the synonym of an Agave.
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Tillandsia juncea", ]
# It is the 75, we remove it! Because the actual species is already there.
epis_occ_families <- epis_occ_families[-75,]
#
#
# Billbergia balansae, the Fuzzy.dist is 3, and it cannot be found anywhere, that is why it got replaced by Dalbergia assamica a Fabaceae. Will be removed.
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Billbergia balansae", ]
# Here we see the database source and references:
occs_final[occs_final$prevScientificName %in% "Billbergia balansae", c(2, 30)]
# We remove both! (1631,1632) Because the species couldn't be found anywhere, e.g. google and references.
epis_occ_families <- epis_occ_families[-c(1630,1631),]
#
#
# Polypodium coriaceum to Rumohra adiantiformis
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium coriaceum", ]
# A search in WorldofPlants.de revealed:
# Polypodium coriaceum (Kaulf. ex Spreng.) Mett. Family Polypodiaceae Synonym of: Loxogramme lanceolata (Sw.) C. Presl
# Polypodium coriaceum Raddi Family Polypodiaceae Synonym of: Niphidium crassifolium (L.) Lellinger
# Polypodium coriaceum Roxb. Family Polypodiaceae Synonym of: Pyrrosia angustata (Sw.) Ching
# Polypodium coriaceum Sw. Family Dryopteridaceae Synonym of: Rumohra adiantiformis (G. Forst.) Ching
# The last entry is the one option in WFO, whereas in WofPlants there are at least four concepts.
occs_final[occs_final$prevScientificName %in% "Polypodium coriaceum", ]
# Based on the Reference, Bussmann2001, the only name that is distributed in Ecuador (the publication is about the ECSF: Estación Científica San Francisco/Ecuador) is Niphidium crassifolium (L.) Lellinger
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Niphidium crassifolium", ]# It is in the families file
occs_final[occs_final$prevScientificName %in% "Niphidium crassifolium", ]# It is in the original list, but see to it that is it in the ECSF [as Polypodium coriaceum L.] #ToDo
# It is the 2177, we change the family.
epis_occ_families$family[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium coriaceum"]<-"Polypodiaceae"
epis_occ_families$genus[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium coriaceum"]<-"Polypodium"
epis_occ_families$scientificName[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium coriaceum"]<- "Polypodium coriaceum"
#
#
# Guzmania truncata to Dumasia truncata
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Guzmania truncata", ]
occs_final[occs_final$prevScientificName %in% "Guzmania truncata", ]
# Couldn't find the reference for the year, perhaps this? [http://upnblib.pedagogica.edu.co/handle/20.500.12209/1894]. Still couldn't find the name there. 
# It will be removed! It is the 3651.
epis_occ_families <- epis_occ_families[-3648,]
#
#
# Lellingeria affinis to Coniogramme affinis
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Lellingeria affinis", ]
occs_final[occs_final$prevScientificName %in% "Lellingeria affinis", ]
# This species remains as "Lellingeria affinis", although is not in WFO, in WofPlants exists as provided. Perhaps, I need to use the "database_id" instead of WFO ID for those which are not in WFO, unless it has its own ID, which it does:
backbone_f_fromSH[backbone_f_fromSH$ABBREVIAT %in% "Lellingeria affinis",]# It is in our backbone!
# So I will replace the family (as it needs to be assigned) and genera (just in case).
epis_occ_families$family[epis_occ_families$spec.name.ORIG %in% 
                    "Lellingeria affinis"]<-"Polypodiaceae"
epis_occ_families$genus[epis_occ_families$spec.name.ORIG %in% 
                    "Lellingeria affinis"]<-"Lellingeria"
epis_occ_families$scientificName[epis_occ_families$spec.name.ORIG %in% 
                    "Lellingeria affinis"]<- "Lellingeria affinis"
#
#
# Polypodium pubescens to Polystichopsis pubescens
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium pubescens", ]
occs_final[occs_final$prevScientificName %in% "Polypodium pubescens", ]
backbone_f_fromSH[backbone_f_fromSH$ABBREVIAT %in% "Serpocaulon lasiopus",]# It is supposed to be synonym of this species, according to the website, but we do not have that synonym in the Backbone! #ToDo [verify the new version of the Backbone with this species in the EpIG project]
# So I will replace the family (as it needs to be assigned) and genera (just in case).
epis_occ_families$family[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium pubescens"]<-"Polypodiaceae"
epis_occ_families$genus[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium pubescens"]<-"Polypodium"
epis_occ_families$scientificName[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium pubescens"]<-"Polypodium pubescens"
#
#
# Ceradenia kegeliana to Gurania lobata
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Ceradenia kegeliana", ]
occs_final[occs_final$prevScientificName %in% "Ceradenia kegeliana", ]
# There are two, I will remove the one that leads to Family Cucurbitaceae (9701):
epis_occ_families <- epis_occ_families[-9697,]
#
backbone_f_fromSH[backbone_f_fromSH$ABBREVIAT %in% "Ceradenia kegeliana",]# It is in our backbone!
# So I will replace the family (as it needs to be assigned) and genera (just in case).
epis_occ_families$family[epis_occ_families$spec.name.ORIG %in% 
                    "Ceradenia kegeliana"]<-"Polypodiaceae"
epis_occ_families$genus[epis_occ_families$spec.name.ORIG %in% 
                    "Ceradenia kegeliana"]<-"Ceradenia"
epis_occ_families$scientificName[epis_occ_families$spec.name.ORIG %in% 
                    "Ceradenia kegeliana"]<-"Ceradenia kegeliana"
#
#
# Cyrtopodium cf. parvifolium to Suaeda dendroides
# This is incorrectly written, it should be "Cyrtopodium parvifolium", so I will just keep the suggested one as such: 11479, the others will be removed: 11477,11478, 11480.
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Cyrtopodium cf. parvifolium", ]
occs_final[occs_final$prevScientificName %in% "Cyrtopodium cf. parvifolium", ]
epis_occ_families <- epis_occ_families[-c(11472, 11473,11475),]
#
#
# Grobya bibrachiata var. riograndensis to Grislea bibrachiata var. riograndensis.
epis_occ_families[epis_occ_families$spec.name.ORIG %in% 
                    "Grobya bibrachiata var. riograndensis", ]
occs_final[occs_final$prevScientificName %in% "Grobya bibrachiata var. riograndensis", ]
# The species including the variety is NOT in the backbone, nor in WFO. But without it, is, therefore I will use it as such.
backbone_f_fromSH[backbone_f_fromSH$ABBREVIAT %in% "Grobya bibrachiata",]# It is as spp only in the backbone
epis_occ_families$family[epis_occ_families$spec.name.ORIG %in% 
                    "Grobya bibrachiata var. riograndensis"]<-"Orchidaceae"
epis_occ_families$genus[epis_occ_families$spec.name.ORIG %in% 
                    "Grobya bibrachiata var. riograndensis"]<-"Grobya"
epis_occ_families$scientificName[epis_occ_families$spec.name.ORIG %in% 
                    "Grobya bibrachiata var. riograndensis"]<-"Grobya bibrachiata var. riograndensis"
#
#
# Polypodium null to Thelypteris rudis this is a morpho, "null" means cero in English, it is likely from FWerner (DELETE ENTRIES)
epis_occ_families[epis_occ_families$spec.name.ORIG %in% "Polypodium null",]
occs_final[occs_final$prevScientificName %in% "Polypodium null", ]
# Although the source stated is [SpeciesLink], I was not able to search anything, so I will delete all entries of the species, including the one below:
# Polypodium null to Athyrium filix-femina subsp. filix-femina, this is a morpho, "null" means cero in English, it is likely from FWerner (DELETE ENTRIES: 12084-12091)
epis_occ_families <- epis_occ_families[ -c(12076:12083),]
#
#
# Polypodium serrulatum to Thelypteris lunaniana, although it cannot be found in the baackbone, it should be there, as synonym of
epis_occ_families[epis_occ_families$spec.name.ORIG %in% "Polypodium serrulatum",]
occs_final[occs_final$prevScientificName %in% "Polypodium serrulatum", ]
backbone_f_fromSH[backbone_f_fromSH$ABBREVIAT %in% "Cochlidium serrulatum",]
# So I will leave the species as and replace family and genus. Maybe I can use this to test the new backbone [#ToDO]
epis_occ_families$family[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium serrulatum"]<-"Polypodiaceae"
epis_occ_families$genus[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium serrulatum"]<-"Polypodium"
epis_occ_families$scientificName[epis_occ_families$spec.name.ORIG %in% 
                    "Polypodium serrulatum"]<-"Polypodium serrulatum"
#
#
# Miltonia flavida to Miconia flavida
epis_occ_families[epis_occ_families$spec.name.ORIG %in% "Miltonia flavida",]
occs_final[occs_final$prevScientificName %in% "Miltonia flavida", ]
backbone_f_fromSH[backbone_f_fromSH$ABBREVIAT %in% "Miltonia flava",]# This species appears as shown in the backbone, as flavida is nowhere to be found, unless in SpeciesLink, which I couldn't find. So I will simply remove the one indicated as Melastomataceae: 12566.
epis_occ_families <- epis_occ_families[-12550,]
#
#
# Anathallis grandiflora to Lysimachia monelli
epis_occ_families[epis_occ_families$spec.name.ORIG %in% "Anathallis grandiflora",]
occs_final[occs_final$prevScientificName %in% "Anathallis grandiflora", ]
# Is not found anywhere [NYB SpeciesLink], so I will remove it: 13011.
epis_occ_families <- epis_occ_families[-12994,]
#
#
# Moranopteris blepharolepis to Dryopteris sublacera
epis_occ_families[epis_occ_families$spec.name.ORIG %in% "Moranopteris blepharolepis",]
occs_final[occs_final$prevScientificName %in% "Moranopteris blepharolepis", ]
#This was identified by M. Lehnert, so I will assign the right family, but it cannot be found anywhere[source: Polypodiaceae of America].
epis_occ_families$family[epis_occ_families$spec.name.ORIG %in% 
                    "Moranopteris blepharolepis"]<-"Polypodiaceae"
epis_occ_families$genus[epis_occ_families$spec.name.ORIG %in% 
                    "Moranopteris blepharolepis"]<-"Moranopteris"
epis_occ_families$scientificName[epis_occ_families$spec.name.ORIG %in% 
                    "Moranopteris blepharolepis"]<-"Moranopteris blepharolepis"
#
#
# Maxillaria tachirensis to Cryptopapillaria helictophylla
epis_occ_families[epis_occ_families$spec.name.ORIG %in% "Maxillaria tachirensis",]
occs_final[occs_final$prevScientificName %in% "Maxillaria tachirensis", ]
# The source is Selby, it is as a generic note[https://tropicos.org/specimen/101683091], but is found no where, I will change to the original data. So I will just leave one (the first one) and replace: 14499, 14500-14507.
epis_occ_families <- epis_occ_families[-c(14482:14489),]
#
#
# Anthurium pusilum to Deparia confluens
epis_occ_families[epis_occ_families$spec.name.ORIG %in% "Anthurium pusilum",]
occs_final[occs_final$prevScientificName %in% "Anthurium pusilum", ]
# The souce is Ingram & Nadkarni 1993, but it was copied wrongly: "Anthurium scandens subsp. pusillum Sheffer", which is a SUBSPP of "Anthurium scandens (Aubl.) Engl.", DO WE HAVE SUBSPP? in the backbone? I do not think so. 
backbone_f_fromSH[backbone_f_fromSH$ABBREVIAT %in% "Anthurium scandens",]
occs_final[occs_final$prevScientificName %in% "Anthurium scandens",]# So, it is everywhere, so I can remove them: 15774 - 15785.
epis_occ_families <- epis_occ_families[-c(15748:15759),]
#
#
# Anthurium grandiflorum to Paradisea liliastrum
epis_occ_families[epis_occ_families$spec.name.ORIG %in% "Anthurium grandiflorum",]
occs_final[occs_final$prevScientificName %in% "Anthurium grandiflorum", ]
occs_final[occs_final$prevScientificName %in% "Anthurium grandifolium", ]
backbone_f_fromSH[backbone_f_fromSH$ABBREVIAT %in% "Anthurium grandifolium",]
# It seems to be a mistake in the publication, the only species that could be is grandifolium, so I will remove it as the other one is already in the DB: 15801.
epis_occ_families <- epis_occ_families[-15763,]


# How many are left?
dim(epis_occ_families)
table(duplicated(epis_occ_families$spec.name.ORIG))
epis_occ_families[duplicated(epis_occ_families$spec.name.ORIG),]
# Revise the family situation:
table(epis_occ_families$family)# Fixed!
```


I use the "epis_occ_families$family" file to update the source: "EpIG_occ.match$scientificName", but I can also use the previous "families" from Maria Judith's file. So this needs to be rethinked:

prev.Family = occs_final$family
prev.Genus = occs_final$genus
Family = epis_occ_families_new$families
Genus = epis_occ_families_new$genus
prevFullName = EpIG_occ.match$spec.name.ORIG[occs_final$prevFullName/occs_final$prevScientificName]
prevscientificName = occs_final$prevScientificName

```{r}
# I need to append the families and every other data from "epis_occ_families" to "EpIG_occ.match" and all of this to the original file:
dim(EpIG_occ.match)
length(unique(EpIG_occ.match$spec.name.ORIG))
dim(epis_occ_families)
length(unique(epis_occ_families$spec.name.ORIG))
# The difference IS because of the removed spp:
setdiff(EpIG_occ.match$spec.name.ORIG,
epis_occ_families$spec.name.ORIG)# These species couldn't be found anywhere, so they were removed.

# There are 13 species which were lost from the "occs_final" file to the "occs_epig", likely not in the match and the families:
setdiff(occs_final$prevScientificName,
        occs_epig$spec.name.ORIG)
# "Brassavola cucullata"       
# "Campyloneurum angustifolium"
# "Campyloneurum phyllitidis"  
# "Epidendrum raniferum"       
# "Galactodenia delicatula"    
# "Goniophlebium furfuraceum"  
# "Laelia anceps"
# Plus the other ones (six) removed from the families object, make up a total of 4951 entries/rows.

# The differences may be due to duplicates:
# This is the total number of species from the initial file:
# species number
length(unique(occs_final$prevScientificName))#15937
# This should be reflected in the file:
length(unique(epis_occ_families$spec.name.ORIG))# minus 9 species removed
table(duplicated(epis_occ_families$scientificName))# apparently several duplicates(4757), it could be that the spec.name.ORIG or spec.name are synonyms

# So we replace in the original file:
dim(EpIG_occ.match)
dim(epis_occ_families)
colnames(EpIG_occ.match)
colnames(epis_occ_families)
# But first, we remove columns which do not have data 
head(epis_occ_families)
dim(epis_occ_families)

epis_occ_families<-epis_occ_families[-c(3:5,10:11,
                                        20:22,24),]
# Nonetheless these were active, they can be used to find mistakes or small things to fix:
# Squished
# Brackets.detected
# Number.detected
# OriSeq
# Subseq
# Subfamily
# tribe
# subtribe
# subgenus


# Then we look at the duplicated entries
epis_occ_families[duplicated(epis_occ_families$scientificName),]

# Need to revise this, but in the meantime
# Relevant columns to compare the duplicates:
epis_occ_families[duplicated(epis_occ_families$scientificName)|duplicated(epis_occ_families$scientificName, fromLast=TRUE),c(2,15,18,7:10)]
# Realizing that some duplicates are really nonesense
epis_occ_families[epis_occ_families$scientificName %in% "Brassavola cucullata",c(7:12)]


# For all those which are duplicated, seems like WFO gathers the accepted name first and then the "unckecked" names or those which are similar but because of a small change they are repeated. So with a unique will suffice!
epis_occ_families[duplicated(epis_occ_families$scientificName),]
#
#
# I check for the CORRECTNESS of the previous families. 
occs_final[(occs_final$prevFamily == occs_final$family)== FALSE,
           c(3, 61, 21, 59)]# Correct the wrong families here:
# First I create a subset
toDel <- occs_final[(occs_final$prevFamily == occs_final$family)== FALSE,
           c(3, 61, 21, 59)]
# Replacing
toDel$prevFamily[c(1:12)] <- toDel$family[c(1:12)]
toDel$family[13] <- toDel$prevFamily[13]
toDel$prevFamily[c(14:18)] <- toDel$family[c(14:18)]
# Replacing in the bigger dataset:
occs_final[(occs_final$prevFamily == occs_final$family)== FALSE,
           c(3, 61, 21, 59)]<-toDel
rm(toDel)
# Checking everything is fine:
occs_final[(occs_final$prevFamily == occs_final$family)== FALSE,
           c(3, 61, 21, 59)]
#
#
# Species number
length(unique(occs_final$prevScientificName))#15937

# Create new dataframe:
# To assign families and genera from [EpIG_occ.match]
occs_final_wfo_fam_gen <- occs_final
# Cheking the order is exactly the same
table(unique(occs_final_wfo_fam_gen$prevScientificName) == EpIG_occ.match$spec.name.ORIG)# All TRUE, it is
# Use data table to make unique datasets (remove duplicates, which are assumed to be the second, third lines and most likely not accepted)
#
# Adding string text so to know is the dataframe with the WFO match columns
EpIG_occ.match <- EpIG_occ.match %>% rename_with(~paste0(.x, '_wfo'), colnames(EpIG_occ.match))
colnames(EpIG_occ.match)[2]<-"spec.name.ORIG"# keeping this to match with other dataframes
#
#
# Fixing the family output!
library(data.table)
setDT(epis_occ_families)
# Here we removed as many duplicates as possible
epis_occ_families_uni <- epis_occ_families[, if(uniqueN(spec.name.ORIG) == 1) .SD, by = .(family, genus, spec.name.ORIG)]
# Here we removed them all:
epis_occ_families_uni <- epis_occ_families_uni[!duplicated(epis_occ_families_uni$spec.name.ORIG)]
# Here I will add a string to the dataframe to recognize thesecolumns are from the families dataframe:
epis_occ_families_uni<- epis_occ_families_uni %>% rename_with(~paste0(.x, '_fam'), colnames(epis_occ_families_uni))
colnames(epis_occ_families_uni)[3]<-"spec.name.ORIG"
#
# Here we assigning families and genera, as well as scientificName and WFO ID [acceptedNameUsageID]
# First I use the previous scientific name to be "spec.name.ORIG":
colnames(occs_final_wfo_fam_gen)[3]<-"spec.name.ORIG"
#
# Join them, first assigning families and genera
occs_final_wfo_fam_gen_final <- inner_join(occs_final_wfo_fam_gen, epis_occ_families_uni, by="spec.name.ORIG", relationship =
  "many-to-many")
rm(occs_final_wfo_fam_gen)
#
#
# FINAL RESULT/OBJECT:
#
# Join results and matched, to add WFO backbone data:
occs_final_wfo_fam_gen_final <- inner_join(occs_final_wfo_fam_gen_final, EpIG_occ.match, by="spec.name.ORIG")
#
# Smaller name
occs_epig <- occs_final_wfo_fam_gen_final
rm(occs_final_wfo_fam_gen_final)
# What are the actual important columns headings?
colnames(occs_epig)

```

Checking for the consistency between Maria Judith's file, (provided previous data) with the assignment according to WFO (families and genera) as well as between WFO assignment and our Backbone assignment for the genera.
```{r}
# FAMILIES before and WFO assigned
occs_epig %>% filter((occs_epig$prevFamily == occs_epig$family_fam)==FALSE)# See above, this mitakes should not be there! #ToDo

# GENERA before and WFO assigned
occs_epig %>% filter((occs_epig$prevGenus == occs_epig$genus_fam)==FALSE)# This makes sense, probably easier to check with Hassler for this.
# These are across all five families, but barely on Araceae and Piperaceae, while largely on Polypodiaceae, followed by Orchidaceae and Bromeliaceae, it is a total of 51,319, a small percentage of the total 8.89%.

# Before and WFO assigned (Backbone EpIG!)
dim(occs_epig %>% filter((occs_epig$spec.name.ORIG == occs_epig$scientificName_wfo)==FALSE))

# How many unique species?
table(occs_epig$acceptedNameUsageID_fam == occs_epig$acceptedNameUsageID_wfo)# It is clear that the Fuzzy tool is quick but an issue, I will keep the IDs assigned by our Backbone:
length(unique(occs_epig$acceptedNameUsageID_wfo))#11283
```


Re adjusting from the output and the merges:
_fam headers come from the WFO output assigning families and genera to the "prevscientificName". Whereas wfo comes from the match of "prevscientificName" in out backbone, so the following should be as follows:

prevFamily = prevFamily
prevGenus = prevGenus
Family = family_fam [!]
Genus = genus_fam [!]
prevFullName = prevFullName
prevscientificName = prevScientificName
ID = acceptedNameUsageID_wfo [!]

```{r}

aa <- occs_epig

aa <- aa %>%
    mutate(family = coalesce(prevFamily, family_fam)) %>%  # Combine into 'family'
    select(-prevFamily)  # Remove 'prevFamily' column
  
  aa <- aa %>%
    mutate(genus = coalesce(prevGenus, genus_fam)) %>%  # Combine into 'genus'
    select(-prevGenus)
  aa <- aa %>%
    mutate(scientificName = coalesce(prevFullName, spec.name.ORIG))  # Combine into 'genus'
  
  
  aa<- aa %>%
    select(
      #class = class,
      #order =order,
      family=family,
      genus=genus,
      species = species,
      #infraspecificEpithet = specificEpithet,
      scientificName = scientificName,
      
      decimalLatitude = decimalLatitude,
      decimalLongitude = decimalLongitude,
      year = year) %>%
    mutate(year = as.integer(year))
  # Example of replacing problematic characters
  aa <- aa %>%
    mutate(scientificName = str_replace_all(scientificName, "�", ""))
  


aa %<>%
  mutate(ID = 1:nrow(.)) %>%
  relocate(ID, .before = 1) %>%
  separate(scientificName, into = c("G", "S", "extra"), extra = "merge", sep = " ") %>%
  mutate(
    # Create 'binomial' by combining 'G' and 'S'
    binomial = paste(G, S, sep = "_"),
    
    # Create 'scientificName' by combining 'G', 'S', and 'extra' with conditional logic
    scientificName = ifelse(
      is.na(extra) | extra == "",
      paste(G, S, sep = " "),  # Use only 'G' and 'S' if 'extra' is NA or empty
      paste(G, S, extra, sep = " ")  # Include 'extra' if it's not NA or empty
    )
  ) %>%
  select(-G, -S, -extra) %>%
  relocate(binomial, .before = 2) %>%
  filter(species != "")


save(aa,
      file = "data/occ_epIGbackbone.Rdata")


#Adds an ID column for each record.
#Rearranges the columns to move the ID to the first position.
#Splits the scientificName column into genus (G), species (S), and any extra information.
#Combines the genus and species into a new column called binomial.
#Recombines the scientificName column without the extra information.
#Filters out records where the species field is empty.
```

From here I should be able to go to line 2115 and run the code as it follows. #ToDo 



We need to use lamberts equal area or Behrmann equal area. The code below is from the file:
"F:/Academic/e_Student_Supervision/Andreas/Shortfalls/code/Sorted analysis skript.R", whatever code I used above is from this source:

